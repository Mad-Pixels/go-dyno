package templates

const CodeTemplate = `
// Code generated by code generator. DO NOT EDIT.

package {{.PackageName}}

import (
    "fmt"
    "context"
    "encoding/json"
    "strings"
    "strconv"
    "sort"

    "github.com/aws/aws-sdk-go-v2/aws"
    "github.com/aws/aws-sdk-go-v2/service/dynamodb"
    "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
    "github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
    "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
    "github.com/aws/aws-lambda-go/events"
)

const (
    TableName = "{{.TableName}}"
    {{range .SecondaryIndexes}}
    Index{{.Name}} = "{{.Name}}"
    {{- end}}
)

const (
    {{range .AllAttributes}}
    Column{{SafeName .Name | ToCamelCase}} = "{{.Name}}"
    {{- end}}
)

var (
    AttributeNames = []string{
        {{- range .AllAttributes}}
        "{{.Name}}",
        {{- end}}
    }

    IndexProjections = map[string][]string{
        {{- range .SecondaryIndexes}}
        "{{.Name}}": {
            {{- if eq .ProjectionType "ALL"}}
            {{- range $.AllAttributes}}
            "{{.Name}}",
            {{- end}}
            {{- else}}
            "{{.HashKey}}", {{if .RangeKey}}"{{.RangeKey}}",{{end}}
            {{- range .NonKeyAttributes}}
            "{{.}}",
            {{- end}}
            {{- end}}
        },
        {{- end}}
    }
)

type DynamoSchema struct {
    TableName        string
    HashKey          string
    RangeKey         string
    Attributes       []Attribute
    CommonAttributes []Attribute
    SecondaryIndexes []SecondaryIndex
}

type Attribute struct {
    Name string
    Type string
}

type CompositeKeyPart struct {
    IsConstant bool
    Value      string
}

type SecondaryIndex struct {
    Name             string
    HashKey          string
    HashKeyParts     []CompositeKeyPart
    RangeKey         string
    RangeKeyParts    []CompositeKeyPart
    ProjectionType   string
    NonKeyAttributes []string
}

// SchemaItem represents an item in "{{.TableName}}"
type SchemaItem struct {
    {{range .AllAttributes}}
    {{SafeName .Name | ToCamelCase}} {{TypeGo .Type}} ` + "`dynamodbav:\"{{.Name}}\"`" + `
    {{end}}
}

var TableSchema = DynamoSchema{
    TableName: "{{.TableName}}",
    HashKey:   "{{.HashKey}}",
    RangeKey:  "{{.RangeKey}}",
    Attributes: []Attribute{
        {{- range .Attributes}}
        {Name: "{{.Name}}", Type: "{{.Type}}"},
        {{- end}}
    },
    CommonAttributes: []Attribute{
        {{- range .CommonAttributes}}
        {Name: "{{.Name}}", Type: "{{.Type}}"},
        {{- end}}
    },
    SecondaryIndexes: []SecondaryIndex{
        {{- range .SecondaryIndexes}}
        {
            Name:           "{{.Name}}",
            HashKey:        "{{.HashKey}}",
            RangeKey:       "{{.RangeKey}}",
            ProjectionType: "{{.ProjectionType}}",
            {{- if .NonKeyAttributes}}
            NonKeyAttributes: []string{
                {{- range .NonKeyAttributes}}
                "{{.}}",
                {{- end}}
            },
            {{- end}}
        },
        {{- end}}
    },
}

type QueryBuilder struct {
    IndexName           string
    KeyConditions       map[string]expression.KeyConditionBuilder
    FilterConditions    []expression.ConditionBuilder
    UsedKeys            map[string]bool
    Attributes          map[string]interface{}
    SortDescending      bool
    LimitValue          *int
    ExclusiveStartKey   map[string]types.AttributeValue
    PreferredSortKey    string
}

func NewQueryBuilder() *QueryBuilder {
    return &QueryBuilder{
        KeyConditions:   make(map[string]expression.KeyConditionBuilder),
        UsedKeys:        make(map[string]bool),
        Attributes:      make(map[string]interface{}),
    }
}

{{range .AllAttributes}}
func (qb *QueryBuilder) With{{SafeName .Name | ToCamelCase}}({{SafeName .Name | ToLowerCamelCase}} {{TypeGo .Type}}) *QueryBuilder {
    attrName := "{{.Name}}"
    qb.Attributes[attrName] = {{SafeName .Name | ToLowerCamelCase}}
    qb.UsedKeys[attrName] = true
    return qb
}
{{end}}

{{range .SecondaryIndexes}}
{{if gt (len .HashKeyParts) 0}}
{{ $methodParams := "" }}
{{ range $index, $part := .HashKeyParts }}
    {{ if not $part.IsConstant }}
        {{ $paramName := (SafeName $part.Value | ToLowerCamelCase) }}
        {{ $paramType := (TypeGoAttr $part.Value $.AllAttributes) }}
        {{ if eq $methodParams "" }}
            {{ $methodParams = printf "%s %s" $paramName $paramType }}
        {{ else }}
            {{ $methodParams = printf "%s, %s %s" $methodParams $paramName $paramType }}
        {{ end }}
    {{ end }}
{{ end }}
func (qb *QueryBuilder) With{{ToCamelCase .Name}}HashKey({{ $methodParams }}) *QueryBuilder {
    {{ range $index, $part := .HashKeyParts }}
    {{ if not $part.IsConstant }}
    {
        attrName := "{{ $part.Value }}"
        qb.Attributes[attrName] = {{ $part.Value | ToLowerCamelCase }}
        qb.UsedKeys[attrName] = true
        qb.KeyConditions[attrName] = expression.Key(attrName).Equal(expression.Value({{ $part.Value | ToLowerCamelCase }}))
    }
    {{ end }}
    {{ end }}
    return qb
}
{{end}}
{{end}}

func (qb *QueryBuilder) WithPreferredSortKey(key string) *QueryBuilder {
    qb.PreferredSortKey = key
    return qb
}

{{range .SecondaryIndexes}}
{{if gt (len .RangeKeyParts) 0}}
{{ $methodParams := "" }}
{{ range $index, $part := .RangeKeyParts }}
    {{ if not $part.IsConstant }}
        {{ $paramName := (SafeName $part.Value | ToLowerCamelCase) }}
        {{ $paramType := (TypeGoAttr $part.Value $.AllAttributes) }}
        {{ if eq $methodParams "" }}
            {{ $methodParams = printf "%s %s" $paramName $paramType }}
        {{ else }}
            {{ $methodParams = printf "%s, %s %s" $methodParams $paramName $paramType }}
        {{ end }}
    {{ end }}
{{ end }}
func (qb *QueryBuilder) With{{ToCamelCase .Name}}RangeKey({{ $methodParams }}) *QueryBuilder {
    {{ range .RangeKeyParts }}
    {{ if not .IsConstant }}
    {
        attrName := "{{ .Value }}"
        qb.Attributes[attrName] = {{ .Value | ToLowerCamelCase }}
        qb.UsedKeys[attrName] = true
        qb.KeyConditions[attrName] = expression.Key(attrName).Equal(expression.Value({{ .Value | ToLowerCamelCase }}))
    }
    {{ end }}
    {{ end }}
    return qb
}
{{end}}
{{end}}

func (qb *QueryBuilder) Build() (string, expression.KeyConditionBuilder, *expression.ConditionBuilder, map[string]types.AttributeValue, error) {
    var filterCond *expression.ConditionBuilder

    // Определяем индексы по приоритету: сначала проверяем индексы с большим количеством атрибутов ключа
    sortedIndexes := make([]SecondaryIndex, len(TableSchema.SecondaryIndexes))
    copy(sortedIndexes, TableSchema.SecondaryIndexes)
    
    // Сортируем индексы по убыванию количества частей в ключе (индексы с большим числом ключевых атрибутов - приоритетнее)
// Сортируем индексы, отдавая предпочтение тем, у которых RangeKey совпадает с предпочтительным ключом сортировки
sort.Slice(sortedIndexes, func(i, j int) bool {
    // Если задан предпочтительный ключ сортировки
    if qb.PreferredSortKey != "" {
        // Проверяем совпадение RangeKey с предпочтительным ключом
        iMatches := sortedIndexes[i].RangeKey == qb.PreferredSortKey
        jMatches := sortedIndexes[j].RangeKey == qb.PreferredSortKey
        
        // Если только один из индексов совпадает, предпочитаем его
        if iMatches && !jMatches {
            return true
        }
        if !iMatches && jMatches {
            return false
        }
    }
    
    // В остальных случаях сортируем по количеству атрибутов в ключе
    iParts := 0
    if sortedIndexes[i].HashKeyParts != nil {
        iParts += len(sortedIndexes[i].HashKeyParts)
    }
    if sortedIndexes[i].RangeKeyParts != nil {
        iParts += len(sortedIndexes[i].RangeKeyParts)
    }
    
    jParts := 0
    if sortedIndexes[j].HashKeyParts != nil {
        jParts += len(sortedIndexes[j].HashKeyParts)
    }
    if sortedIndexes[j].RangeKeyParts != nil {
        jParts += len(sortedIndexes[j].RangeKeyParts)
    }
    
    return iParts > jParts
})

    // Пытаемся найти индекс, подходящий для запроса
    for _, idx := range sortedIndexes {
        var hashKeyCondition, rangeKeyCondition *expression.KeyConditionBuilder
        var hashKeyMatch, rangeKeyMatch bool

        // Проверка HashKey
        if idx.HashKeyParts != nil {
            if qb.hasAllKeys(idx.HashKeyParts) {
                cond := qb.buildCompositeKeyCondition(idx.HashKeyParts)
                hashKeyCondition = &cond
                hashKeyMatch = true
            }
        } else if idx.HashKey != "" && qb.UsedKeys[idx.HashKey] {
            cond := expression.Key(idx.HashKey).Equal(expression.Value(qb.Attributes[idx.HashKey]))
            hashKeyCondition = &cond
            hashKeyMatch = true
        }

        if !hashKeyMatch {
            continue // Этот индекс не подходит
        }

// Проверка RangeKey с особым приоритетом для сортировки
// Если у нас есть несколько подходящих индексов с одинаковым ключом хеша,
// мы выберем тот, который лучше соответствует условиям сортировки
if idx.RangeKeyParts != nil {
    if qb.hasAllKeys(idx.RangeKeyParts) {
        cond := qb.buildCompositeKeyCondition(idx.RangeKeyParts)
        rangeKeyCondition = &cond
        rangeKeyMatch = true
    }
} else if idx.RangeKey != "" {
    // Проверяем, есть ли конкретное условие по ключу сортировки
    if qb.UsedKeys[idx.RangeKey] {
        if cond, exists := qb.KeyConditions[idx.RangeKey]; exists {
            rangeKeyCondition = &cond
            rangeKeyMatch = true
        } else {
            // Индекс все равно считается подходящим, даже если нет условия по ключу сортировки
            rangeKeyMatch = true
        }
    } else {
        // Индекс все равно считается подходящим, даже если нет условия по ключу сортировки
        rangeKeyMatch = true
    }
} else {
    rangeKeyMatch = true
}

        if !rangeKeyMatch {
            continue
        }

        // Нашли подходящий индекс!
        keyCondition := *hashKeyCondition
        if rangeKeyCondition != nil {
            keyCondition = keyCondition.And(*rangeKeyCondition)
        }

        // Собираем фильтры для всех атрибутов, которые не являются частью ключа
        for attrName, value := range qb.Attributes {
            // Проверяем, не является ли атрибут частью ключа индекса
            isPartOfHashKey := false
            isPartOfRangeKey := false
            
            if idx.HashKeyParts != nil {
                for _, part := range idx.HashKeyParts {
                    if !part.IsConstant && part.Value == attrName {
                        isPartOfHashKey = true
                        break
                    }
                }
            } else if attrName == idx.HashKey {
                isPartOfHashKey = true
            }
            
            if idx.RangeKeyParts != nil {
                for _, part := range idx.RangeKeyParts {
                    if !part.IsConstant && part.Value == attrName {
                        isPartOfRangeKey = true
                        break
                    }
                }
            } else if attrName == idx.RangeKey {
                isPartOfRangeKey = true
            }
            
            // Если атрибут не является частью ключа, добавляем его в фильтр
            if !isPartOfHashKey && !isPartOfRangeKey {
                cond := expression.Name(attrName).Equal(expression.Value(value))
                qb.FilterConditions = append(qb.FilterConditions, cond)
            }
        }

        // Объединяем все условия фильтрации
        if len(qb.FilterConditions) > 0 {
            combinedFilter := qb.FilterConditions[0]
            for _, cond := range qb.FilterConditions[1:] {
                combinedFilter = combinedFilter.And(cond)
            }
            filterCond = &combinedFilter
        }

        return idx.Name, keyCondition, filterCond, qb.ExclusiveStartKey, nil
    }

    // Если ни один вторичный индекс не подходит, пробуем использовать основной ключ таблицы
    if qb.UsedKeys[TableSchema.HashKey] {
        indexName := ""
        keyCondition := expression.Key(TableSchema.HashKey).Equal(expression.Value(qb.Attributes[TableSchema.HashKey]))

        // Добавляем условие по ключу диапазона, если он есть
if TableSchema.RangeKey != "" && qb.UsedKeys[TableSchema.RangeKey] {
    if cond, exists := qb.KeyConditions[TableSchema.RangeKey]; exists {
        keyCondition = keyCondition.And(cond)
    } else {
        keyCondition = keyCondition.And(expression.Key(TableSchema.RangeKey).Equal(expression.Value(qb.Attributes[TableSchema.RangeKey])))
    }
}

        // Добавляем все остальные атрибуты как фильтры
        for attrName, value := range qb.Attributes {
            if attrName != TableSchema.HashKey && attrName != TableSchema.RangeKey {
                cond := expression.Name(attrName).Equal(expression.Value(value))
                qb.FilterConditions = append(qb.FilterConditions, cond)
            }
        }

        // Объединяем все условия фильтрации
        if len(qb.FilterConditions) > 0 {
            combinedFilter := qb.FilterConditions[0]
            for _, cond := range qb.FilterConditions[1:] {
                combinedFilter = combinedFilter.And(cond)
            }
            filterCond = &combinedFilter
        }

        return indexName, keyCondition, filterCond, qb.ExclusiveStartKey, nil
    }

    return "", expression.KeyConditionBuilder{}, nil, nil, fmt.Errorf("no suitable index found for the provided keys")
}

func (qb *QueryBuilder) hasAllKeys(parts []CompositeKeyPart) bool {
    for _, part := range parts {
        if !part.IsConstant && !qb.UsedKeys[part.Value] {
            return false
        }
    }
    return true
}

func (qb *QueryBuilder) buildCompositeKeyCondition(parts []CompositeKeyPart) expression.KeyConditionBuilder {
    var compositeKeyValue string
    for i, part := range parts {
        var valueStr string
        if part.IsConstant {
            valueStr = part.Value
        } else {
            value := qb.Attributes[part.Value]
            valueStr = fmt.Sprintf("%v", value)
        }
        if i > 0 {
            compositeKeyValue += "#"
        }
        compositeKeyValue += valueStr
    }
    compositeKeyName := qb.getCompositeKeyName(parts)
    return expression.Key(compositeKeyName).Equal(expression.Value(compositeKeyValue))
}

func (qb *QueryBuilder) getCompositeKeyName(parts []CompositeKeyPart) string {
    var names []string
    for _, part := range parts {
        names = append(names, part.Value)
    }
    return strings.Join(names, "#")
}

func (qb *QueryBuilder) BuildQuery() (*dynamodb.QueryInput, error) {
    indexName, keyCond, filterCond, exclusiveStartKey, err := qb.Build()
    if err != nil {
        return nil, err
    }

    exprBuilder := expression.NewBuilder().WithKeyCondition(keyCond)
    if filterCond != nil {
        exprBuilder = exprBuilder.WithFilter(*filterCond)
    }

    expr, err := exprBuilder.Build()
    if err != nil {
        return nil, fmt.Errorf("failed to build expression: %v", err)
    }

    input := &dynamodb.QueryInput{
        TableName:                 aws.String(TableName),
        KeyConditionExpression:    expr.KeyCondition(),
        ExpressionAttributeNames:  expr.Names(),
        ExpressionAttributeValues: expr.Values(),
        ScanIndexForward:          aws.Bool(!qb.SortDescending),
    }

    if indexName != "" {
        input.IndexName = aws.String(indexName)
    }

    if filterCond != nil {
        input.FilterExpression = expr.Filter()
    }

    if qb.LimitValue != nil {
        input.Limit = aws.Int32(int32(*qb.LimitValue))
    }

    if exclusiveStartKey != nil {
        input.ExclusiveStartKey = exclusiveStartKey
    }

    return input, nil
}

func (qb *QueryBuilder) Execute(ctx context.Context, client *dynamodb.Client) ([]SchemaItem, error) {
    input, err := qb.BuildQuery()
    if err != nil {
        return nil, err
    }

    result, err := client.Query(ctx, input)
    if err != nil {
        return nil, fmt.Errorf("failed to execute query: %v", err)
    }

    var items []SchemaItem
    err = attributevalue.UnmarshalListOfMaps(result.Items, &items)
    if err != nil {
        return nil, fmt.Errorf("failed to unmarshal result: %v", err)
    }

    return items, nil
}

{{range .AllAttributes}}
{{if eq (TypeGo .Type) "int"}}
func (qb *QueryBuilder) With{{SafeName .Name | ToCamelCase}}Between(start, end {{TypeGo .Type}}) *QueryBuilder {
    attrName := "{{.Name}}"
    qb.KeyConditions[attrName] = expression.Key(attrName).Between(expression.Value(start), expression.Value(end))
    qb.UsedKeys[attrName] = true
    return qb
}

func (qb *QueryBuilder) With{{SafeName .Name | ToCamelCase}}GreaterThan(value {{TypeGo .Type}}) *QueryBuilder {
    attrName := "{{.Name}}"
    qb.KeyConditions[attrName] = expression.Key(attrName).GreaterThan(expression.Value(value))
    qb.UsedKeys[attrName] = true
    return qb
}

func (qb *QueryBuilder) With{{SafeName .Name | ToCamelCase}}LessThan(value {{TypeGo .Type}}) *QueryBuilder {
    attrName := "{{.Name}}"
    qb.KeyConditions[attrName] = expression.Key(attrName).LessThan(expression.Value(value))
    qb.UsedKeys[attrName] = true
    return qb
}
{{end}}
{{end}}

func (qb *QueryBuilder) OrderByDesc() *QueryBuilder {
    qb.SortDescending = true
    return qb
}

func (qb *QueryBuilder) OrderByAsc() *QueryBuilder {
    qb.SortDescending = false
    return qb
}

func (qb *QueryBuilder) Limit(limit int) *QueryBuilder {
    qb.LimitValue = &limit
    return qb
}

func (qb *QueryBuilder) StartFrom(lastEvaluatedKey map[string]types.AttributeValue) *QueryBuilder {
    qb.ExclusiveStartKey = lastEvaluatedKey
    return qb
}

func BatchPutItems(items []SchemaItem) ([]map[string]types.AttributeValue, error) {
    result := make([]map[string]types.AttributeValue, 0, len(items))
    for _, item := range items {
        av, err := PutItem(item)
        if err != nil {
            return nil, fmt.Errorf("failed to marshal item: %v", err)
        }
        result = append(result, av)
    }
    return result, nil
}

// PutItem creates an AttributeValues map for PutItem in DynamoDB
func PutItem(item SchemaItem) (map[string]types.AttributeValue, error) {
    attributeValues, err := attributevalue.MarshalMap(item)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal item: %v", err)
    }
    return attributeValues, nil
}

func BoolToInt(b bool) int {
    if b {
        return 1
    }
    return 0
}

func IntToBool(i int) bool {
    return i != 0
}

// ExtractFromDynamoDBStreamEvent DynamoDB Stream to SchemaItem
func ExtractFromDynamoDBStreamEvent(dbEvent events.DynamoDBEventRecord) (*SchemaItem, error) {
    if dbEvent.Change.NewImage == nil {
        return nil, fmt.Errorf("new image is nil in the event")
    }
    
    item := &SchemaItem{}
    
    {{range .AllAttributes}}
    if val, ok := dbEvent.Change.NewImage["{{.Name}}"]; ok {
        {{if eq .Type "S"}}
        item.{{SafeName .Name | ToCamelCase}} = val.String()
        {{else if eq .Type "N"}}
        if n, err := strconv.Atoi(val.Number()); err == nil {
            item.{{SafeName .Name | ToCamelCase}} = n
        }
        {{else if eq .Type "B"}}
        item.{{SafeName .Name | ToCamelCase}} = val.Boolean()
        {{end}}
    }
    {{end}}
    
    return item, nil
}

// IsFieldModified DynamoDB Stream to check if field was modified
func IsFieldModified(dbEvent events.DynamoDBEventRecord, fieldName string) bool {
    if dbEvent.EventName != "MODIFY" {
        return false
    }
    
    if dbEvent.Change.OldImage == nil || dbEvent.Change.NewImage == nil {
        return false
    }
    
    oldVal, oldExists := dbEvent.Change.OldImage[fieldName]
    newVal, newExists := dbEvent.Change.NewImage[fieldName]
    
    if !oldExists || !newExists {
        return false
    }
    
    return oldVal.String() != newVal.String()
}

func GetBoolFieldChanged(dbEvent events.DynamoDBEventRecord, fieldName string) bool {
    if dbEvent.EventName != "MODIFY" {
        return false
    }
    
    if dbEvent.Change.OldImage == nil || dbEvent.Change.NewImage == nil {
        return false
    }
    
    oldValue := false
    if oldVal, ok := dbEvent.Change.OldImage[fieldName]; ok {
        oldValue = oldVal.Boolean()
    }
    
    newValue := false
    if newVal, ok := dbEvent.Change.NewImage[fieldName]; ok {
        newValue = newVal.Boolean()
    }
    
    return !oldValue && newValue
}

func CreateKey(hashKeyValue interface{}, rangeKeyValue interface{}) (map[string]types.AttributeValue, error) {
    key := make(map[string]types.AttributeValue)
    
    hashKeyAV, err := attributevalue.Marshal(hashKeyValue)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal hash key: %v", err)
    }
    key[TableSchema.HashKey] = hashKeyAV
    
    if TableSchema.RangeKey != "" && rangeKeyValue != nil {
        rangeKeyAV, err := attributevalue.Marshal(rangeKeyValue)
        if err != nil {
            return nil, fmt.Errorf("failed to marshal range key: %v", err)
        }
        key[TableSchema.RangeKey] = rangeKeyAV
    }
    
    return key, nil
}

func CreateKeyFromItem(item SchemaItem) (map[string]types.AttributeValue, error) {
    key := make(map[string]types.AttributeValue)
    
    var hashKeyValue interface{}
    {{range .AllAttributes}}{{if eq .Name $.HashKey}}
    hashKeyValue = item.{{SafeName .Name | ToCamelCase}}
    {{end}}{{end}}
    
    hashKeyAV, err := attributevalue.Marshal(hashKeyValue)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal hash key: %v", err)
    }
    key[TableSchema.HashKey] = hashKeyAV
    
    if TableSchema.RangeKey != "" {
        var rangeKeyValue interface{}
        {{range .AllAttributes}}{{if eq .Name $.RangeKey}}
        rangeKeyValue = item.{{SafeName .Name | ToCamelCase}}
        {{end}}{{end}}
        
        rangeKeyAV, err := attributevalue.Marshal(rangeKeyValue)
        if err != nil {
            return nil, fmt.Errorf("failed to marshal range key: %v", err)
        }
        key[TableSchema.RangeKey] = rangeKeyAV
    }
    
    return key, nil
}

func CreateTriggerHandler(
    onInsert func(context.Context, *SchemaItem) error,
    onModify func(context.Context, *SchemaItem, *SchemaItem) error,
    onDelete func(context.Context, map[string]events.DynamoDBAttributeValue) error,
) func(ctx context.Context, event events.DynamoDBEvent) error {
    return func(ctx context.Context, event events.DynamoDBEvent) error {
        for _, record := range event.Records {
            switch record.EventName {
            case "INSERT":
                if onInsert != nil {
                    item, err := ExtractFromDynamoDBStreamEvent(record)
                    if err != nil {
                        return err
                    }
                    if err := onInsert(ctx, item); err != nil {
                        return err
                    }
                }
                
            case "MODIFY":
                if onModify != nil {
                    oldItem, err := ExtractFromDynamoDBStreamEvent(events.DynamoDBEventRecord{
                        Change: events.DynamoDBStreamRecord{
                            NewImage: record.Change.OldImage,
                        },
                    })
                    if err != nil {
                        return err
                    }
                    
                    newItem, err := ExtractFromDynamoDBStreamEvent(record)
                    if err != nil {
                        return err
                    }
                    
                    if err := onModify(ctx, oldItem, newItem); err != nil {
                        return err
                    }
                }
                
            case "REMOVE":
                if onDelete != nil {
                    if err := onDelete(ctx, record.Change.OldImage); err != nil {
                        return err
                    }
                }
            }
        }
        return nil
    }
}

func ConvertMapToAttributeValues(input map[string]interface{}) (map[string]types.AttributeValue, error) {
    result := make(map[string]types.AttributeValue)
    
    for key, value := range input {
        switch v := value.(type) {
        case string:
            result[key] = &types.AttributeValueMemberS{Value: v}
        case float64:
            // Числа в JSON обычно представлены как float64
            if v == float64(int64(v)) {
                // Целое число
                result[key] = &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", int64(v))}
            } else {
                result[key] = &types.AttributeValueMemberN{Value: fmt.Sprintf("%g", v)}
            }
        case bool:
            if v {
                result[key] = &types.AttributeValueMemberN{Value: "1"} // Для совместимости с вашим BoolToInt
            } else {
                result[key] = &types.AttributeValueMemberN{Value: "0"}
            }
        case nil:
            result[key] = &types.AttributeValueMemberNULL{Value: true}
        case map[string]interface{}:
            // Обработка вложенных объектов
            b, err := json.Marshal(v)
            if err != nil {
                return nil, err
            }
            result[key] = &types.AttributeValueMemberM{
                Value: map[string]types.AttributeValue{
                    "json": &types.AttributeValueMemberS{Value: string(b)},
                },
            }
        case []interface{}:
            // Обработка массивов
            b, err := json.Marshal(v)
            if err != nil {
                return nil, err
            }
            result[key] = &types.AttributeValueMemberL{
                Value: []types.AttributeValue{
                    &types.AttributeValueMemberS{Value: string(b)},
                },
            }
        default:
            return nil, fmt.Errorf("unsupported type for key %s: %T", key, value)
        }
    }
    
    return result, nil
}
`
